// Generated by CoffeeScript 2.2.2
(function() {
  var CellState, GameOfGeister, GeisterObj, Player;

  GeisterObj = (function() {
    class GeisterObj {
      constructor(color, player) {
        this.color = color;
        this.player = player;
      }

    };

    GeisterObj.COLOR_NONE = 0;

    GeisterObj.COLOR_RED = 1;

    GeisterObj.COLOR_BLUE = 2;

    GeisterObj.PLAYER_NONE = 0;

    GeisterObj.PLAYER_A = 1;

    GeisterObj.PLAYER_B = 2;

    GeisterObj.prototype.color = null;

    GeisterObj.prototype.player = null;

    GeisterObj.prototype.hidden = false;

    GeisterObj.prototype.moving = false;

    return GeisterObj;

  }).call(this);

  CellState = (function() {
    class CellState {
      constructor(row1, column1) {
        var ref;
        this.row = row1;
        this.column = column1;
        if ((2 <= (ref = this.column) && ref <= 5)) {
          if (this.row === 1) {
            this.obj = new GeisterObj(GeisterObj.COLOR_RED, GeisterObj.PLAYER_A);
          } else if (this.row === 6) {
            this.obj = new GeisterObj(GeisterObj.COLOR_RED, GeisterObj.PLAYER_B);
          } else if (this.row === 2) {
            this.obj = new GeisterObj(GeisterObj.COLOR_BLUE, GeisterObj.PLAYER_A);
          } else if (this.row === 5) {
            this.obj = new GeisterObj(GeisterObj.COLOR_BLUE, GeisterObj.PLAYER_B);
          } else {
            this.obj = new GeisterObj(GeisterObj.COLOR_NONE, GeisterObj.PLAYER_NONE);
          }
        } else {
          this.obj = new GeisterObj(GeisterObj.COLOR_NONE, GeisterObj.PLAYER_NONE);
        }
      }

    };

    CellState.prototype.obj = null;

    return CellState;

  }).call(this);

  Player = (function() {
    class Player {
      constructor() {
        this.got_obj = [];
      }

      got(o) {
        return this.got_obj.push(o);
      }

    };

    Player.prototype.got_obj = null;

    return Player;

  }).call(this);

  GameOfGeister = (function() {
    class GameOfGeister {
      constructor() {
        this.game_status = 'PREPARE';
        this.createCanvas();
        this.resizeCanvas();
        this.createDrawingContext();
        $('#start').click(() => {
          return this.readyGame();
        });
        $('#gameboard').mousedown((e) => {
          return this.mouseDown(e);
        });
        this.ready_resources();
      }

      ready_resources(f) {
        this.arrow_img = new Image();
        this.arrow_img.src = "arrow.png?" + new Date().getTime();
        return this.arrow_img.onload = () => {
          this.geister_obj_img = new Image();
          this.geister_obj_img.src = "geister_obj.png?" + new Date().getTime();
          return this.geister_obj_img.onload = () => {
            this.geister_red_img = new Image();
            this.geister_red_img.src = "geister_red.png?" + new Date().getTime();
            return this.geister_red_img.onload = () => {
              this.geister_blue_img = new Image();
              this.geister_blue_img.src = "geister_blue.png?" + new Date().getTime();
              return this.geister_blue_img.onload = () => {
                return this.initGame();
              };
            };
          };
        };
      }

      initGame() {
        this.playerA = new Player();
        this.playerB = new Player();
        this.game_status = 'PREPARE';
        this.initCells();
        return this.drawBoard();
      }

      swapOwnObj(n) {
        var c, c0, c1, column, i, j, k, l, myCells, ref, ref1, ref2, results, row;
        myCells = [];
        for (row = j = 0, ref = this.numberOfRows; (0 <= ref ? j < ref : j > ref); row = 0 <= ref ? ++j : --j) {
          for (column = k = 0, ref1 = this.numberOfColumns; (0 <= ref1 ? k < ref1 : k > ref1); column = 0 <= ref1 ? ++k : --k) {
            c = this.currentCell[row][column];
            if (c.obj.player === GeisterObj.PLAYER_A) {
              myCells.push(c);
            }
          }
        }
        results = [];
        for (i = l = 0, ref2 = n; (0 <= ref2 ? l < ref2 : l > ref2); i = 0 <= ref2 ? ++l : --l) {
          c0 = myCells[parseInt(Math.random() * myCells.length)];
          c1 = myCells[parseInt(Math.random() * myCells.length)];
          results.push(this.swapObject(c0.column, c0.row, c1.column, c1.row));
        }
        return results;
      }

      readyGame() {
        var column, j, k, ref, ref1, row, start;
        for (row = j = 0, ref = this.numberOfRows; (0 <= ref ? j < ref : j > ref); row = 0 <= ref ? ++j : --j) {
          for (column = k = 0, ref1 = this.numberOfColumns; (0 <= ref1 ? k < ref1 : k > ref1); column = 0 <= ref1 ? ++k : --k) {
            if (this.currentCell[row][column].obj.player === GeisterObj.PLAYER_A) {
              this.currentCell[row][column].obj.hidden = true;
            }
          }
        }
        this.drawBoard();
        this.swapOwnObj(100);
        this.game_status = 'RUN';
        return start = $('#start')[0].disabled = true;
      }

      isEscapeWin() {
        if (this.currentCell[6][0].obj.player === GeisterObj.PLAYER_A) {
          return GeisterObj.PLAYER_A;
        }
        if (this.currentCell[7][1].obj.player === GeisterObj.PLAYER_A) {
          return GeisterObj.PLAYER_A;
        }
        if (this.currentCell[6][7].obj.player === GeisterObj.PLAYER_A) {
          return GeisterObj.PLAYER_A;
        }
        if (this.currentCell[7][6].obj.player === GeisterObj.PLAYER_A) {
          return GeisterObj.PLAYER_A;
        }
        if (this.currentCell[0][1].obj.player === GeisterObj.PLAYER_B) {
          return GeisterObj.PLAYER_B;
        }
        if (this.currentCell[1][0].obj.player === GeisterObj.PLAYER_B) {
          return GeisterObj.PLAYER_B;
        }
        if (this.currentCell[0][6].obj.player === GeisterObj.PLAYER_B) {
          return GeisterObj.PLAYER_B;
        }
        if (this.currentCell[1][7].obj.player === GeisterObj.PLAYER_B) {
          return GeisterObj.PLAYER_B;
        }
        return GeisterObj.PLAYER_NONE;
      }

      countObjColor() {
        var a, column, j, k, o, ref, ref1, row;
        a = [
          0,
          0,
          0,
          0 // A.RED, A.BLUE, B.RED, B.BLUE
        ];
        for (row = j = 0, ref = this.numberOfRows; (0 <= ref ? j < ref : j > ref); row = 0 <= ref ? ++j : --j) {
          for (column = k = 0, ref1 = this.numberOfColumns; (0 <= ref1 ? k < ref1 : k > ref1); column = 0 <= ref1 ? ++k : --k) {
            o = this.currentCell[row][column].obj;
            if (o.player === GeisterObj.PLAYER_A) {
              if (o.color === GeisterObj.COLOR_RED) {
                a[0] = a[0] + 1;
              } else {
                a[1] = a[1] + 1;
              }
            } else if (o.player === GeisterObj.PLAYER_B) {
              if (o.color === GeisterObj.COLOR_RED) {
                a[2] = a[2] + 1;
              } else {
                a[3] = a[3] + 1;
              }
            }
          }
        }
        return a;
      }

      nextGame() {
        var p;
        p = this.checkGame();
        if (p === GeisterObj.PLAYER_NONE) {
          if (this.turn === 'B') {
            this.turn = 'A';
            return this.simplePlayerOp();
          } else {
            return this.turn = 'B';
          }
        } else {
          this.drawBoard();
          if (p === GeisterObj.PLAYER_A) {
            alert('CPU Win!!');
          } else {
            alert('You Win!!');
          }
          return this.initGame();
        }
      }

      checkGame() {
        var colors, winner;
        winner = this.isEscapeWin();
        if (winner !== GeisterObj.PLAYER_NONE) {
          return winner;
        }
        colors = this.countObjColor();
        if (colors[0] === 0) { // A.RED  == 0
          return GeisterObj.PLAYER_A;
        }
        if (colors[1] === 0) { // A.BLUE == 0
          return GeisterObj.PLAYER_B;
        }
        if (colors[2] === 0) { // B.RED  == 0
          return GeisterObj.PLAYER_B;
        }
        if (colors[3] === 0) { // B.BLUE == 0
          return GeisterObj.PLAYER_A;
        }
        return GeisterObj.PLAYER_NONE;
      }

      isEscapeMove(obj, x, y, dx, dy) {
        //                console.log(player)
        if (obj.player === GeisterObj.PLAYER_B && obj.color === GeisterObj.COLOR_BLUE) {
          if (x === 1 && y === 1 && dx === -1 && dy === 0) {
            return true;
          }
          if (x === 1 && y === 1 && dx === 0 && dy === -1) {
            return true;
          }
          if (x === 6 && y === 1 && dx === 1 && dy === 0) {
            return true;
          }
          if (x === 6 && y === 1 && dx === 0 && dy === -1) {
            return true;
          }
          return false;
        } else if (obj.player === GeisterObj.PLAYER_A && obj.color === GeisterObj.COLOR_BLUE) {
          if (x === 1 && y === 6 && dx === -1 && dy === 0) {
            return true;
          }
          if (x === 1 && y === 6 && dx === 0 && dy === 1) {
            return true;
          }
          if (x === 6 && y === 6 && dx === 1 && dy === 0) {
            return true;
          }
          if (x === 6 && y === 6 && dx === 0 && dy === 1) {
            return true;
          }
          return false;
        } else {
          return false;
        }
      }

      isIllegalMove(x, y, dx, dy) {
        var o, ref, ref1, t;
        o = this.currentCell[y][x];
        if (this.isEscapeMove(o.obj, x, y, dx, dy)) {
          return true;
        }
        if (!((dx === 0 && Math.abs(dy) === 1) || (Math.abs(dx) === 1 && dy === 0))) {
          return false;
        }
        if (!((0 < (ref = y + dy) && ref < this.numberOfRows - 1))) {
          return false;
        }
        if (!((0 < (ref1 = x + dx) && ref1 < this.numberOfColumns - 1))) {
          return false;
        }
        t = this.currentCell[y + dy][x + dx];
        if (t.obj.player === o.obj.player) {
          return false;
        }
        return true;
      }

      simplePlayerOp() {
        var c, candidates, column, j, k, l, len, o, objects, ref, ref1, result, row;
        objects = [];
        candidates = [];
        for (row = j = 0, ref = this.numberOfRows; (0 <= ref ? j < ref : j > ref); row = 0 <= ref ? ++j : --j) {
          for (column = k = 0, ref1 = this.numberOfColumns; (0 <= ref1 ? k < ref1 : k > ref1); column = 0 <= ref1 ? ++k : --k) {
            if (this.currentCell[row][column].obj.player === GeisterObj.PLAYER_A) {
              objects.push([row, column]);
            }
          }
        }
        for (l = 0, len = objects.length; l < len; l++) {
          o = objects[l];
          if (this.isIllegalMove(o[1], o[0], 0, 1)) {
            candidates.push([o[1], o[0], 0, 1]);
          }
          if (this.isIllegalMove(o[1], o[0], 0, -1)) {
            candidates.push([o[1], o[0], 0, -1]);
          }
          if (this.isIllegalMove(o[1], o[0], 1, 0)) {
            candidates.push([o[1], o[0], 1, 0]);
          }
          if (this.isIllegalMove(o[1], o[0], -1, 0)) {
            candidates.push([o[1], o[0], -1, 0]);
          }
        }
        //                for c in candidates
        //                        console.log(c)

        // select
        c = candidates[parseInt(Math.random() * candidates.length)];
        //                console.log("select:")
        //                console.log(c)
        result = this.moveOperation(c[0], c[1], c[0] + c[2], c[1] + c[3]);
        this.drawBoard();
        return this.nextGame();
      }

      getXPosition(v) {
        return parseInt(v / this.cellSize);
      }

      getYPosition(v) {
        return parseInt(v / this.cellSize);
      }

      clearMouseEvent() {
        if (this.selectedItem !== null) {
          this.selectedItem.moving = false;
        }
        this.selectedX = null;
        this.selectedY = null;
        this.selectedItem = null;
        this.drawBoard();
        $('#gameboard').unbind("mouseup mousemove mouseleave");
        return $(this).unbind("mouseup mousemove mouseleave");
      }

      swapObject(sx, sy, ex, ey) {
        var c_tmp, eo, p_tmp, so;
        so = this.currentCell[sy][sx].obj;
        eo = this.currentCell[ey][ex].obj;
        if (so.player === eo.player) {
          p_tmp = so.player;
          c_tmp = so.color;
          so.player = eo.player;
          so.color = eo.color;
          eo.player = p_tmp;
          return eo.color = c_tmp;
        }
      }

      moveOperation(sx, sy, ex, ey) {
        var c_tmp, eo, h_tmp, p_tmp, result, so;
        console.log("move: " + sx + "," + sy + "->" + ex + "," + ey);
        this.selectedItem.moving = false;
        so = this.currentCell[sy][sx].obj;
        eo = this.currentCell[ey][ex].obj;
        result = new GeisterObj(eo.color, eo.player); // new obj
        if (this.isIllegalMove(sx, sy, ex - sx, ey - sy) === true) {
          p_tmp = so.player;
          c_tmp = so.color;
          h_tmp = so.hidden;
          so.player = GeisterObj.PLAYER_NONE;
          so.color = GeisterObj.COLOR_NONE;
          so.hidden = false;
          eo.player = p_tmp;
          eo.color = c_tmp;
          eo.hidden = h_tmp;
          return result;
        } else {
          //                        console.log("set:" + ex + "," + ey + "<-" + p_tmp + "," + c_tmp);
          //                        console.log(@currentCell[ex][ey])
          return false;
        }
      }

      mouseUp(e) {
        var ex, ey, result, sx, sy;
        ex = this.getXPosition(e.offsetX);
        ey = this.getYPosition(e.offsetY);
        sx = this.getXPosition(this.selectedX);
        sy = this.getYPosition(this.selectedY);
        if (this.game_status === 'READY') {
          this.swapObject(sx, sy, ex, ey);
        }
        if (this.game_status === 'RUN' && this.turn === 'B') {
          if (this.isIllegalMove(sx, sy, ex - sx, ey - sy)) {
            result = this.moveOperation(sx, sy, ex, ey);
            if (result.player !== GeisterObj.PLAYER_NONE) {
              this.playerB.got(result);
            }
            this.nextGame();
          }
        }
        return this.clearMouseEvent();
      }

      mouseLeave(e) {
        return this.clearMouseEvent();
      }

      mouseMove(e) {
        var img;
        if (this.selectedItem !== null) {
          this.drawBoard();
          img = this.getObjImage(this.selectedItem);
          return this.drawingContext.drawImage(img, e.offsetX - this.cellSize / 2, e.offsetY - this.cellSize / 2, this.cellSize, this.cellSize);
        }
      }

      mouseDown(e) {
        var column, row;
        if (!(this.game_status === 'READY' || (this.game_status === 'RUN' && this.turn === 'B'))) {
          return;
        }
        column = this.getXPosition(e.offsetX);
        row = this.getYPosition(e.offsetY);
        if (this.currentCell[row][column].obj.player === GeisterObj.PLAYER_B) {
          this.selectedItem = this.currentCell[row][column].obj;
          this.selectedX = e.offsetX;
          this.selectedY = e.offsetY;
          this.selectedItem.moving = true;
          $('#gameboard').mousemove((e) => {
            return this.mouseMove(e);
          });
          $('#gameboard').mouseleave((e) => {
            return this.mouseLeave(e);
          });
          return $('#gameboard').mouseup((e) => {
            return this.mouseUp(e);
          });
        }
      }

      createCanvas() {
        return this.canvas = $('#gameboard')[0];
      }

      resizeCanvas() {
        this.canvas.height = this.cellSize * this.numberOfRows;
        return this.canvas.width = this.cellSize * this.numberOfColumns;
      }

      createDrawingContext() {
        return this.drawingContext = this.canvas.getContext('2d');
      }

      initCells() {
        var column, j, ref, results, row;
        this.currentCell = [];
        results = [];
        for (row = j = 0, ref = this.numberOfRows; (0 <= ref ? j < ref : j > ref); row = 0 <= ref ? ++j : --j) {
          this.currentCell[row] = [];
          results.push((function() {
            var k, ref1, results1;
            results1 = [];
            for (column = k = 0, ref1 = this.numberOfColumns; (0 <= ref1 ? k < ref1 : k > ref1); column = 0 <= ref1 ? ++k : --k) {
              results1.push(this.currentCell[row][column] = new CellState(row, column));
            }
            return results1;
          }).call(this));
        }
        return results;
      }

      drawImage(img, x, y, rot) {
        if (rot) {
          this.drawingContext.save();
          this.drawingContext.rotate(180 * Math.PI / 180);
          x = (-x - 1) * this.cellSize;
          y = (-y - 1) * this.cellSize;
        } else {
          x = x * this.cellSize;
          y = y * this.cellSize;
        }
        this.drawingContext.drawImage(img, x, y, this.cellSize, this.cellSize);
        if (rot) {
          return this.drawingContext.restore();
        }
      }

      drawBoard() {
        var i, j, len, o, rdy, ref;
        this.drawingContext.clearRect(0, 0, this.drawingContext.canvas.clientWidth, this.drawingContext.canvas.clientHeight);
        this.drawImage(this.arrow_img, 1, 1, false);
        this.drawImage(this.arrow_img, 6, 1, true);
        this.drawImage(this.arrow_img, 1, 6, false);
        this.drawImage(this.arrow_img, 6, 6, true);
        this.drawGrid();
        ref = this.playerB.got_obj;
        //                console.log(@playerB.got_obj)
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          o = ref[i];
          this.drawImage(this.getObjImage(o), i, 7, true);
        }
        if (this.game_status === 'PREPARE') {
          this.game_status = 'READY';
          return rdy = $('#start')[0].disabled = false;
        }
      }

      drawGrid() {
        var column, j, ref, results, row;
        results = [];
        for (row = j = 0, ref = this.numberOfRows; (0 <= ref ? j < ref : j > ref); row = 0 <= ref ? ++j : --j) {
          results.push((function() {
            var k, ref1, results1;
            results1 = [];
            for (column = k = 0, ref1 = this.numberOfColumns; (0 <= ref1 ? k < ref1 : k > ref1); column = 0 <= ref1 ? ++k : --k) {
              results1.push(this.drawCell(this.currentCell[row][column]));
            }
            return results1;
          }).call(this));
        }
        return results;
      }

      getObjImage(obj) {
        var img;
        if (obj.hidden === true && $('#debug').is(':checked') === false) {
          img = this.geister_obj_img;
        } else if (obj.color === GeisterObj.COLOR_BLUE) {
          img = this.geister_blue_img;
        } else {
          img = this.geister_red_img;
        }
        return img;
      }

      drawCell(cell) {
        var img, ref, ref1, strk, x, y;
        x = cell.column * this.cellSize;
        y = cell.row * this.cellSize;
        if (cell.obj.player !== GeisterObj.PLAYER_NONE && cell.obj.moving === false) {
          img = this.getObjImage(cell.obj);
          this.drawImage(img, cell.column, cell.row, cell.obj.player === GeisterObj.PLAYER_A);
        }
        if ((0 < (ref = cell.column) && ref < 7) && (0 < (ref1 = cell.row) && ref1 < 7)) {
          strk = 'rgba(0, 0, 0, 1)';
        } else {
          strk = 'rgba(0, 0, 0, 0)';
        }
        this.drawingContext.strokeStyle = strk;
        return this.drawingContext.strokeRect(x, y, this.cellSize, this.cellSize);
      }

    };

    GameOfGeister.prototype.cellSize = 60;

    GameOfGeister.prototype.numberOfRows = 8;

    GameOfGeister.prototype.numberOfColumns = 8;

    GameOfGeister.prototype.canvas = null;

    GameOfGeister.prototype.drawingContext = null;

    GameOfGeister.prototype.currentCell = null;

    GameOfGeister.prototype.arrow_img = null;

    GameOfGeister.prototype.geister_obj_img = null;

    GameOfGeister.prototype.geister_red_img = null;

    GameOfGeister.prototype.geister_blue_img = null;

    GameOfGeister.prototype.selectedX = null;

    GameOfGeister.prototype.selectedY = null;

    GameOfGeister.prototype.selectedItem = null;

    GameOfGeister.prototype.turn = 'B';

    GameOfGeister.prototype.game_status = 'PREPARE';

    GameOfGeister.prototype.playerA = null;

    GameOfGeister.prototype.playerB = null;

    return GameOfGeister;

  }).call(this);

  window.GameOfGeister = GameOfGeister;

}).call(this);
